#include <iostream>
using namespace std;

class Node{
public:
	int data;
	Node* next;	
	

	Node(){
		data=0;
		next=NULL;
	} 
	  Node(int data) 
    { 
        this->data = data; 
        this->next = NULL; 
    } 
};

class LinkedList{
	Node* head;//head is simply the memory address of the first node, which means tail will be the memory address of the last node
	Node* tail;           //but when sth is not head or tail the memory refernce they have is to the next node.
	public:
		LinkedList(){
			//points to the first node in the linked list.
			// throught the head pointer you can access and manipulate the nodes in thbe linked list
			head=NULL;
			tail=NULL;
		}
		void insertLast(int);//works in constant time
		void insertNode(int);//basically inserts last but at linear time 
		void printList();	
		void insertFirst(int);
		void reverseList();
		void getFirst();
		void deleteFirst();// do this when we doubly link it 
		void deleteLast();//can occur in constant time with a doubly linked list
		void getLast();//can be done efficiently by by storing the tail, a pointer to the last node(data structure augmentation)
		void insertLast();//can be done efficiently by by storing the tail, a pointer to the last node(data structure augmentation)
		void getHead();
	
	
};
//deprecated
void LinkedList::insertNode(int data){
	Node* newNode= new Node(data);/*new creates a memory address. if we create another instance of class node in the same instace of linked list,
	the memory address generated by that next instance is assigned to the next pointer of the head.*/
	
	if(head == NULL){
		head=newNode;
		tail=newNode;
		return;
	}
	Node* temp =head;// we want to start looping from here
	

	while(temp->next != NULL){//despite temp by itself just being a pointer, we have to explicitly say, temp->next cause if we just do temp we will also be referring to the data attribute of the temp variable 
		temp= temp->next;//The loop's goal is to find the last node in the linked list. The last node is characterized by having its next pointer set to NULL
		
	}
	temp->next=newNode;
	
}
void LinkedList::insertLast(int data){
	Node* newNode=new Node(data);
	if(head==NULL){
		head=newNode;
		tail=newNode;
		return;
	}
	Node* lastNode= tail;
    lastNode->next=newNode;
    tail=newNode;	
}
void LinkedList::printList(){
	Node* temp = head;
	if(head==NULL){
		cout<<"List is empty"<<endl;
		return;
	}
	while(temp!=NULL){//if we looped using temp->next,the last number would not be printed out because it has a NULL pointer,using temp refers to the memory address as well as the data attribute and they would both have to be null for printing to stop.
		cout<<temp->data<<" ";
		temp=temp->next;//check out this line next time 
	}
}
void LinkedList::insertFirst(int data){
	Node* newNode=new Node(data);
	if(head==NULL){
		head=newNode;
		tail=newNode;
		return;
	}
	Node* firstItem=head;
    newNode->next=firstItem;
    head=newNode;
	
}
void LinkedList::deleteFirst(){
	if(head==NULL){
		cout<<"the list is empty bitch!";
        return;
	}
	Node* firstItem=head;
	head=firstItem->next;
	delete firstItem;
}
void LinkedList::getFirst(){
	if(head==NULL){
		cout<<"the list is empty";
		return;
	}
	Node* firstNode=head;
	cout<<firstNode->data;
	
}
void LinkedList::getHead(){
	if(head==NULL){
		cout<<"empty";
		return;
	}
	cout<<head->data;
}
void LinkedList::getLast(){
	if(head==NULL){
		cout<<" the list is empty";
		return;
	}
	Node* lastNode=tail;
	cout<<lastNode->data<<" "<<endl;
}


int main(){
	LinkedList list;
	list.insertFirst(0);
	list.insertLast(1);
    list.insertLast(2);	
    list.insertLast(3);	
	list.insertLast(4);
	list.printList();

	/*Change the insertNode function to insertLast. Also corect the insertLast given by gpt, link:"https://chat.openai.com/c/e744e3e0-6d91-435d-8b20-49476628ac37"*/

}